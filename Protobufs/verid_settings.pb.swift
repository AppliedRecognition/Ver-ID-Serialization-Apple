// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: verid_settings.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Verid_VerIDSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var confidenceThreshold: Float {
    get {return _storage._confidenceThreshold}
    set {_uniqueStorage()._confidenceThreshold = newValue}
  }

  var sizeRange: Float {
    get {return _storage._sizeRange}
    set {_uniqueStorage()._sizeRange = newValue}
  }

  var rollRangeLarge: UInt32 {
    get {return _storage._rollRangeLarge}
    set {_uniqueStorage()._rollRangeLarge = newValue}
  }

  var rollRangeSmall: UInt32 {
    get {return _storage._rollRangeSmall}
    set {_uniqueStorage()._rollRangeSmall = newValue}
  }

  var yawRangeLarge: UInt32 {
    get {return _storage._yawRangeLarge}
    set {_uniqueStorage()._yawRangeLarge = newValue}
  }

  var yawRangeSmall: UInt32 {
    get {return _storage._yawRangeSmall}
    set {_uniqueStorage()._yawRangeSmall = newValue}
  }

  var landmarkOptions: UInt32 {
    get {return _storage._landmarkOptions}
    set {_uniqueStorage()._landmarkOptions = newValue}
  }

  var matrixTemplateVersion: UInt32 {
    get {return _storage._matrixTemplateVersion}
    set {_uniqueStorage()._matrixTemplateVersion = newValue}
  }

  var yawPitchVariant: UInt32 {
    get {return _storage._yawPitchVariant}
    set {_uniqueStorage()._yawPitchVariant = newValue}
  }

  var eyeDetectionVariant: UInt32 {
    get {return _storage._eyeDetectionVariant}
    set {_uniqueStorage()._eyeDetectionVariant = newValue}
  }

  var defaultTemplateVersion: UInt32 {
    get {return _storage._defaultTemplateVersion}
    set {_uniqueStorage()._defaultTemplateVersion = newValue}
  }

  var reduceConfidenceCalculation: Bool {
    get {return _storage._reduceConfidenceCalculation}
    set {_uniqueStorage()._reduceConfidenceCalculation = newValue}
  }

  var lightingMatrix: UInt32 {
    get {return _storage._lightingMatrix}
    set {_uniqueStorage()._lightingMatrix = newValue}
  }

  var lightingCompensation: UInt32 {
    get {return _storage._lightingCompensation}
    set {_uniqueStorage()._lightingCompensation = newValue}
  }

  var poseVariant: UInt32 {
    get {return _storage._poseVariant}
    set {_uniqueStorage()._poseVariant = newValue}
  }

  var poseCompensation: UInt32 {
    get {return _storage._poseCompensation}
    set {_uniqueStorage()._poseCompensation = newValue}
  }

  var detectSmile: Bool {
    get {return _storage._detectSmile}
    set {_uniqueStorage()._detectSmile = newValue}
  }

  var qualityThreshold: Float {
    get {return _storage._qualityThreshold}
    set {_uniqueStorage()._qualityThreshold = newValue}
  }

  var attemptMultiThreading: Bool {
    get {return _storage._attemptMultiThreading}
    set {_uniqueStorage()._attemptMultiThreading = newValue}
  }

  var faceExtractQualityThreshold: Float {
    get {return _storage._faceExtractQualityThreshold}
    set {_uniqueStorage()._faceExtractQualityThreshold = newValue}
  }

  var landmarkTrackingQualityThreshold: Float {
    get {return _storage._landmarkTrackingQualityThreshold}
    set {_uniqueStorage()._landmarkTrackingQualityThreshold = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Verid_VerIDSettings: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "verid"

extension Verid_VerIDSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerIDSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confidence_threshold"),
    2: .standard(proto: "size_range"),
    3: .standard(proto: "roll_range_large"),
    4: .standard(proto: "roll_range_small"),
    5: .standard(proto: "yaw_range_large"),
    6: .standard(proto: "yaw_range_small"),
    7: .standard(proto: "landmark_options"),
    8: .standard(proto: "matrix_template_version"),
    9: .standard(proto: "yaw_pitch_variant"),
    10: .standard(proto: "eye_detection_variant"),
    11: .standard(proto: "default_template_version"),
    12: .standard(proto: "reduce_confidence_calculation"),
    13: .standard(proto: "lighting_matrix"),
    14: .standard(proto: "lighting_compensation"),
    15: .standard(proto: "pose_variant"),
    16: .standard(proto: "pose_compensation"),
    17: .standard(proto: "detect_smile"),
    18: .standard(proto: "quality_threshold"),
    19: .standard(proto: "attempt_multi_threading"),
    20: .standard(proto: "face_extract_quality_threshold"),
    21: .standard(proto: "landmark_tracking_quality_threshold"),
  ]

  fileprivate class _StorageClass {
    var _confidenceThreshold: Float = 0
    var _sizeRange: Float = 0
    var _rollRangeLarge: UInt32 = 0
    var _rollRangeSmall: UInt32 = 0
    var _yawRangeLarge: UInt32 = 0
    var _yawRangeSmall: UInt32 = 0
    var _landmarkOptions: UInt32 = 0
    var _matrixTemplateVersion: UInt32 = 0
    var _yawPitchVariant: UInt32 = 0
    var _eyeDetectionVariant: UInt32 = 0
    var _defaultTemplateVersion: UInt32 = 0
    var _reduceConfidenceCalculation: Bool = false
    var _lightingMatrix: UInt32 = 0
    var _lightingCompensation: UInt32 = 0
    var _poseVariant: UInt32 = 0
    var _poseCompensation: UInt32 = 0
    var _detectSmile: Bool = false
    var _qualityThreshold: Float = 0
    var _attemptMultiThreading: Bool = false
    var _faceExtractQualityThreshold: Float = 0
    var _landmarkTrackingQualityThreshold: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _confidenceThreshold = source._confidenceThreshold
      _sizeRange = source._sizeRange
      _rollRangeLarge = source._rollRangeLarge
      _rollRangeSmall = source._rollRangeSmall
      _yawRangeLarge = source._yawRangeLarge
      _yawRangeSmall = source._yawRangeSmall
      _landmarkOptions = source._landmarkOptions
      _matrixTemplateVersion = source._matrixTemplateVersion
      _yawPitchVariant = source._yawPitchVariant
      _eyeDetectionVariant = source._eyeDetectionVariant
      _defaultTemplateVersion = source._defaultTemplateVersion
      _reduceConfidenceCalculation = source._reduceConfidenceCalculation
      _lightingMatrix = source._lightingMatrix
      _lightingCompensation = source._lightingCompensation
      _poseVariant = source._poseVariant
      _poseCompensation = source._poseCompensation
      _detectSmile = source._detectSmile
      _qualityThreshold = source._qualityThreshold
      _attemptMultiThreading = source._attemptMultiThreading
      _faceExtractQualityThreshold = source._faceExtractQualityThreshold
      _landmarkTrackingQualityThreshold = source._landmarkTrackingQualityThreshold
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._confidenceThreshold) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._sizeRange) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._rollRangeLarge) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._rollRangeSmall) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._yawRangeLarge) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._yawRangeSmall) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._landmarkOptions) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._matrixTemplateVersion) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._yawPitchVariant) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._eyeDetectionVariant) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._defaultTemplateVersion) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._reduceConfidenceCalculation) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._lightingMatrix) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._lightingCompensation) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._poseVariant) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._poseCompensation) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._detectSmile) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._qualityThreshold) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._attemptMultiThreading) }()
        case 20: try { try decoder.decodeSingularFloatField(value: &_storage._faceExtractQualityThreshold) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._landmarkTrackingQualityThreshold) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._confidenceThreshold != 0 {
        try visitor.visitSingularFloatField(value: _storage._confidenceThreshold, fieldNumber: 1)
      }
      if _storage._sizeRange != 0 {
        try visitor.visitSingularFloatField(value: _storage._sizeRange, fieldNumber: 2)
      }
      if _storage._rollRangeLarge != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rollRangeLarge, fieldNumber: 3)
      }
      if _storage._rollRangeSmall != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rollRangeSmall, fieldNumber: 4)
      }
      if _storage._yawRangeLarge != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._yawRangeLarge, fieldNumber: 5)
      }
      if _storage._yawRangeSmall != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._yawRangeSmall, fieldNumber: 6)
      }
      if _storage._landmarkOptions != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._landmarkOptions, fieldNumber: 7)
      }
      if _storage._matrixTemplateVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._matrixTemplateVersion, fieldNumber: 8)
      }
      if _storage._yawPitchVariant != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._yawPitchVariant, fieldNumber: 9)
      }
      if _storage._eyeDetectionVariant != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._eyeDetectionVariant, fieldNumber: 10)
      }
      if _storage._defaultTemplateVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._defaultTemplateVersion, fieldNumber: 11)
      }
      if _storage._reduceConfidenceCalculation != false {
        try visitor.visitSingularBoolField(value: _storage._reduceConfidenceCalculation, fieldNumber: 12)
      }
      if _storage._lightingMatrix != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lightingMatrix, fieldNumber: 13)
      }
      if _storage._lightingCompensation != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lightingCompensation, fieldNumber: 14)
      }
      if _storage._poseVariant != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._poseVariant, fieldNumber: 15)
      }
      if _storage._poseCompensation != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._poseCompensation, fieldNumber: 16)
      }
      if _storage._detectSmile != false {
        try visitor.visitSingularBoolField(value: _storage._detectSmile, fieldNumber: 17)
      }
      if _storage._qualityThreshold != 0 {
        try visitor.visitSingularFloatField(value: _storage._qualityThreshold, fieldNumber: 18)
      }
      if _storage._attemptMultiThreading != false {
        try visitor.visitSingularBoolField(value: _storage._attemptMultiThreading, fieldNumber: 19)
      }
      if _storage._faceExtractQualityThreshold != 0 {
        try visitor.visitSingularFloatField(value: _storage._faceExtractQualityThreshold, fieldNumber: 20)
      }
      if _storage._landmarkTrackingQualityThreshold != 0 {
        try visitor.visitSingularFloatField(value: _storage._landmarkTrackingQualityThreshold, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Verid_VerIDSettings, rhs: Verid_VerIDSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._confidenceThreshold != rhs_storage._confidenceThreshold {return false}
        if _storage._sizeRange != rhs_storage._sizeRange {return false}
        if _storage._rollRangeLarge != rhs_storage._rollRangeLarge {return false}
        if _storage._rollRangeSmall != rhs_storage._rollRangeSmall {return false}
        if _storage._yawRangeLarge != rhs_storage._yawRangeLarge {return false}
        if _storage._yawRangeSmall != rhs_storage._yawRangeSmall {return false}
        if _storage._landmarkOptions != rhs_storage._landmarkOptions {return false}
        if _storage._matrixTemplateVersion != rhs_storage._matrixTemplateVersion {return false}
        if _storage._yawPitchVariant != rhs_storage._yawPitchVariant {return false}
        if _storage._eyeDetectionVariant != rhs_storage._eyeDetectionVariant {return false}
        if _storage._defaultTemplateVersion != rhs_storage._defaultTemplateVersion {return false}
        if _storage._reduceConfidenceCalculation != rhs_storage._reduceConfidenceCalculation {return false}
        if _storage._lightingMatrix != rhs_storage._lightingMatrix {return false}
        if _storage._lightingCompensation != rhs_storage._lightingCompensation {return false}
        if _storage._poseVariant != rhs_storage._poseVariant {return false}
        if _storage._poseCompensation != rhs_storage._poseCompensation {return false}
        if _storage._detectSmile != rhs_storage._detectSmile {return false}
        if _storage._qualityThreshold != rhs_storage._qualityThreshold {return false}
        if _storage._attemptMultiThreading != rhs_storage._attemptMultiThreading {return false}
        if _storage._faceExtractQualityThreshold != rhs_storage._faceExtractQualityThreshold {return false}
        if _storage._landmarkTrackingQualityThreshold != rhs_storage._landmarkTrackingQualityThreshold {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
